<!DOCTYPE html>
<html lang="en-US">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>Maeve Stites</title>
  <meta name="keywords" content="personal, portfolio, resume, contact, linkedin, Maeve, Stites, Maeve Stites">
  <meta name="description" content="Electrical and Computer Engineering Major's personal website, portfolio, link to resume, and contact information.">
  <meta name="author" content="Maeve Stites">
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
  <link type="text/css" rel="stylesheet" href="../css/materialize.min.css" media="screen,projection" />
  <link type="text/css" rel="stylesheet" href="../css/style.css" media="screen,projection" />
  <link href="../css/materialdesignicons.min.css" media="all" rel="stylesheet" type="text/css" />
  <link rel="apple-touch-icon" sizes="180x180" href="../images/favicon/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="../images/favicon/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="../images/favicon/favicon-16x16.png">
  <link rel="manifest" href="../images/favicon/site.webmanifest">
  <meta name="msapplication-TileColor" c-ontent="#da532c">
  <meta name="theme-color" content="#f5f6fa">
  <link href="https://fonts.googleapis.com/css2?family=Lato:wght@400;700;900&family=Montserrat:ital,wght@0,300;0,400;0,500;0,600;0,700;0,800;1,300;1,400;1,500;1,600;1,700;1,800&display=swap" rel="stylesheet">
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-106734336-2"></script>
  <script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-106734336-2');
</script>

<!--Let browser know website is optimized for mobile-->
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
</head>

<body>
  <div id="portfolioColumn" class="subpage">
    <div class="subpage">
      <h1>Wax Melter</h1>
      <hr>
      <img src="../images/portfolio/items/wax_melter/high_res.jpg" alt="Cover photo">
      <div>
        <h2>Intro</h2>
        <p>In the fall of 2020, I took a class in microcontrollers. The main assignment was to design a microcontroller circuit for a project that sparked my interests. A passion of mine is candle making, so I chose to design and build a board that solved a real-world problem of mine - temperature control of liquid wax. For this project, I spec'd out and designed the electronics, used KiCAD to layout a printed circuit board and coded the application in C. I also developed a web interface so the board could be monitored remotely.</p>
        </div>
        <div>
          <h2>Results</h2>
          <p>For full code and schematics please see the <a href="https://github.com/mstites/waxMelter">waxMelter</a> github. To see complete testing results, please see the <a href="https://www.youtube.com/playlist?list=PLl34vFjrV3SNVaj6ajRUN01m7x6o9dpL4">full system test videos playlist</a>.</p>
          <div>
            <h3>Board</h3>
            <div class="imageCap">
              <img src="../images/portfolio/items/wax_melter/board/front.jpg" alt="front of the pcb">
              <p>Front of the finalized board with most of the major components: microcontroller, one thermocouple amplifier with room for another, 3.3V linear regulator and associated filering, and screw terminal for relay control.</p>
              <img src="../images/portfolio/items/wax_melter/board/back.jpg" alt="back of the pcb">
              <p>Back of the board with the OLED and button control UI. There is a wire for a connection modification with the thermocouple amplifier to a different analog read port.</p>
            </div>
          </div>
          <div>
            <h3>Usage</h3>
            <div class="imageCap">
              <img src="../images/portfolio/items/wax_melter/action/powerCtrl.jpg" alt="PCB connected to relay control, which looks like a power strip, control unit connected to hot plate via power cable">
              <p>Board controlling the hot plate via the power relay.</p>
              <a href="https://youtu.be/gqc67_deNMM"><img src="../images/portfolio/items/wax_melter/action/heating.jpg" alt="Jar of white flakey wax in a pot of water ontop of hot plate. Thermocouple from board inside of wax, where the board is connected to the relay control unit the board is connected into"></a>
              <p>Board heating a jar of wax in a double broiler system.</p>
            </div>
          </div>

        </div>
        <div>
          <h2>Board Information</h2>
          <div>
            <h3>Parts List and Parts Decisions</h3>
            <p>Below is the parts list for making one board. I ordered more of certain parts (regulators, capacitors, resisters, sockets) with the plan to make more than one board. However, I ended up only making one board as my first design came out very well.</p>
            <ul>
              <li><a href=https://www.adafruit.com/product/3591>Adafruit HUZZAH32</a> - $20.95 - integrated wifi module and common usage in IoT device spaces.</li>
              <li><a href=https://www.adafruit.com/product/1778>Thermocouple Amplifier AD8495</a> - $11.95 - this is basically a chip on a board, but having it in module form makes it much easier to implement. If my budget would have allowed it, I would have bought two of these so I could have measured two temperature points (eg the pot and in the wax).</li>
              <li><a href=https://www.ebay.com/itm/1M-K-Type-Thermocouple-Sensor-Digital-Thermometer-Temperature-Meter-TK80-4JPL8/282896189061?_trkparms=ispr%3D1&hash=item41dded4685:g:auQAAOSwikdau~0I&amdata=enc%3AAQAFAAACYBaobrjLl8XobRIiIML1V4Imu%252Fn%252BzU5L90Z278x5ickk7PdDazAlGltMLJlUhrWsD4ypBzXDBrr3EGbvDCD%252BOTfiTG%252FV6xARDfS6DhxpOawtq0wAUHwzCXVNlrquDkax%252BHLcfCpjODsCClfysZNmLcjKNhUCyZwlivq7Ou%252BSmp%252FNan3zi86bNOppmqGIBMdWiTFE6aq0N55rJ5p610VKqpsEUguP16E0hxd5inmBD20248dYwxENTtrZPJzbteu98xpsFoA6NRRONNO8AFAXX89%252FktMA%252FMYhMde28GDtzsb4Q%252FstK%252BytZGRtmxx2GJeJIjNEnUTIb2ZtmPVtaehLIrKyByYNRhgJ3trD8Uzl1OL1G6Ov1BHTu3ct5z6%252BYjT5Gn1gHn1WTkyAUGmD96HCcMx2kF4PVEo171c0GnQmpCPSK%252Ba1t5ZcDgoZA4wjEhZSgphf9bAZoL%252BTzL9r2Q1FGZkeqwcEwrHTXMSumlt%252FEBQSmBNDBf%252BVZwOZV1DEa5zsk8uRSAahogXBhsBiTncrrOCZMk1M%252Fb6JNapN67fctFa4vXdXtx75DZtH7jcddYi4seuXT9uvLQ%252BGizccfA5TaPQpMoAGivS1TTwWy26Bz2oLF4qjKl8lhn9gjkRAodJqWBnukNI%252BdxfboGJRnL1tupUHN1vHOuuQglrpdetpjcCG2atFgNjEhzRBVdqyXI5UYWCN3p%252FCElSElYjv48XtG05oh%252F%252F0i%252BNC37r2TF%252BFe4q4%252FOPX%252BPEo%252BL9JVKTemFHr%252BIyor4iOTMGOTiiJJ6U9t5zFFEMdbP8pcCW20AqyD6I7%7Ccksum%3A282896189061fe03b50efa204da1abdccf1154f0cbb6%7Campid%3APL_CLK%7Cclp%3A2334524>K Type Thermocouple</a> - $5.75 - a very generic and cheap K type thermocouple. It works fine, but next time I would buy a <a href=https://www.amazon.com/T-PRO-Thermocouple-Temperature-Sensors-Wire%EF%BC%8CStainless/dp/B0748DFJFN/ref=sr_1_1_sspa?crid=3FBR67YVY6O7F&dchild=1&keywords=k+type+thermocouple&qid=1608021933&sprefix=k+type+the%2Caps%2C169&sr=8-1-spons&psc=1&spLa=ZW5jcnlwdGVkUXVhbGlmaWVyPUEySU5GQjJQMU9ZMVE5JmVuY3J5cHRlZElkPUEwMDg1Mjg0U1UwOFRGNkFBNkI1JmVuY3J5cHRlZEFkSWQ9QTA5NDQ1MzExQ1dMSlMwNDdLVDdJJndpZGdldE5hbWU9c3BfYXRmJmFjdGlvbj1jbGlja1JlZGlyZWN0JmRvTm90TG9nQ2xpY2s9dHJ1ZQ%3D%3D>probe</a>.</li>
              <li><a href=https://www.amazon.com/gp/product/B07MMT2SC5/ref=ask_ql_qh_dp_hza>Hot Plate</a> - $22 - The most basic hot plate I could find. When you plug it in, it turns on. When you unplug it, it turns off. Perfect for my board to control.</li>
              <li><a href=https://www.amazon.com/Iot-Relay-Enclosed-High-Power-Raspberry/dp/B00WV7GMA2/ref=sr_1_2?dchild=1&keywords=outlet+power+relay&qid=1601856536&sr=8-2>Outlet Power Relay</a> - $27 - picked this up as it is safer than using a relay to control 120V myself, which understandably my Professor would not let me do for this course.</li>
              <li><a href=https://www.amazon.com/UCTRONICS-SSD1306-Self-Luminous-Display-Raspberry/dp/B072Q2X2LL/ref=sr_1_3?dchild=1&keywords=oled+display+arduino&qid=1602386754&sr=8-3>SPI OLED 128x64</a> - $7 - Simple SPI controlled OLED module. I picked one with the top two lines yellow to use as status indicators.</li>
            </ul>
            <div>
              <h4>Digikey Parts</h4>
              <ul>
                <li><a href=https://www.digikey.com/en/products/detail/stmicroelectronics/LD1117V33/586012>LD1117V33 3.3V 800mA Linear Voltage Regulator</a> - $0.55 - stepping down from 5V to 3.3V for the OLED and the thermocouple modules.</li>
                <li><a href=https://www.digikey.com/en/products/detail/vishay-beyschlag-draloric-bc-components/K104K15X7RF5TL2/286538?s=N4IgTCBcDaIAQCEDCBGADADgCxICoFoA5AERAF0BfIA> 3x 0.1uF Ceramic Capacitor</a> - $0.23 each -  power filtering.</li>
                <li><a href=https://www.digikey.com/en/products/detail/nichicon/UKL1C100KDD1TD/5699141?s=N4IgTCBcDaICwE4DMBaAjHJc7pQOQBEQBdAXyA>2x 10uF Electrolytic Capacitor</a> - $0.27 each - power filtering.</li>
                <li><a href=https://www.digikey.com/en/products/detail/stackpole-electronics-inc/CF18JT4K70/1741708?s=N4IgTCBcDaIMIDECMAOAUgFQCwGkDsADHBgLQByAIiALoC%2BQA>2x 4.7K Resistor 1/8W</a> - $0.10 each - for SPI.</li>
                <li><a href=https://www.digikey.com/en/products/detail/phoenix-contact/1751248/2511016>2 Pin Screw Terminal</a> - $1.26 each - for connecting the thermocouple to the board.</li>
                <li><a href=https://www.digikey.com/en/products/detail/sullins-connector-solutions/PPPC161LFBN-RC/810188?s=N4IgTCBcDaIAQAUkGECMA2VAZAYgIQDkBaAJWRAF0BfIA>16 pin socket</a> - $1.02 - micro controller socket.</li>
                <li><a href=https://www.digikey.com/en/products/detail/sullins-connector-solutions/PPPC121LFBN-RC/810184?s=N4IgTCBcDaIAoIMIEYzIDIDEBCA5AtAEqIgC6AvkA>12 pin socket</a> - $1.82 - micro controller socket.</li>
                <li><a href=https://www.digikey.com/en/products/detail/sullins-connector-solutions/PPPC041LFBN-RC/810176?s=N4IgTCBcDaIAoIMIAYAsBGAMgMQEIDkBaAJURAF0BfIA>2x 4 pin socket</a> - $0.47 each - socket for the thermocouple amplifier and OLED. Long term, it would be best to solder both components for stability.</li>
              </ul>
              <p>Total = $104.60 + shipping + pcb cost</p>
              <p>My project cost total 147.60 with shipping and pcb costs. this included  double the parts from digikey (for a planned second PCB that was not made).
                <p>All of the devices I chose support 3.3V logic. All power will be supplied by the USB adapter. This is not ideal, but this is the only realistic option on the HUZZAH32. The LD1117V33 will be used to power the OLED and the thermocouple modules.</p>
              </div>
            </div>
            <div>
              <h3>Schematic</h3>
              <p>My schematic(s) for this project, click on the image for a full PDF download:</p>
              <div class="imageCap large">
                <a href="../images/portfolio/items/wax_melter/schematic/schematicAsBuilt.pdf"><img src="../images/portfolio/items/wax_melter/schematic/schematicAsBuilt.jpg" alt="As built schematic"></a>
                <p>The schematic as used for my PCB design.</p>
                <a href="../images/portfolio/items/wax_melter/schematic/schematicRecommended.pdf"><img src="../images/portfolio/items/wax_melter/schematic/schematicRecommended.jpg" alt="Recommended schematic"></a>
                <p>Recommended PCB schematic for future iterations.</p>
              </div>
              <p>The key difference between these two schematics is in the analog inputs used for the thermocouple amplifier readings.  In the first iteration, I used A1 and A5 on the ESP32, which are on ADC channel #2. In the second iteration, I used A2  and A4, which  are on ADC channel #2. This change was due to a discovered conflict between WiFi and ADC #2.</p>
              <p>I used a Linear Voltage Regular pulling power from 5V USB to supply 3.3V to all the modules. There is a on board 3.3V regulator on the HUZZAH32 board, which can be used to supply off board components. However, the other modules I have plus the ESP32 would have been up against the limit of the HUZZAH32's on board regulator's capacity and I did not want to interfere with  the chip's power supply. There are a number of capacitors throughout my schematic, 0.1uF and 10uF, for filtering and power stabilization.</p>
            </div>
            <div>
              <h3>PCB Layout</h3>
              <p>With the PCB layout, I had some key design requirements in mind:</p>
              <ol>
                <li>Two layer board</li>
                <li>Stay below 100x100mm</li>
                <li>Position all off PCB wires in a convenient location</li>
              </ol>
              <p>One and two reduce cost and simplify my board. I also wanted my board to be small, so it would be  convenient to package in the future. For the third consideration, there are a lot of wires going off board: up to four wires for thermocouples, two wires for relay control, and a micro usb cable for power. I wanted to make sure these did not make the unit cumbersome to use.</p>
              <p>With those considerations in mind, I created the following PCB:</p>
              <div class="imageCap">
                <img src="../images/portfolio/items/wax_melter/pcb/pcb3d.jpg" alt="front of the pcb">
                <p>Front of the PCB with all of the core components mounting to this side: microcontroller, thermocouple amplifiers, power components, and screw terminal for relay control.</p>
                <img src="../images/portfolio/items/wax_melter/pcb/pcb3dback.jpg" alt="back of the pcb">
                <p>Back of the PCB with only the OLED and buttons mounting to it.</p>
                <img src="../images/portfolio/items/wax_melter/pcb/footprint.jpg" alt="pcb footprint">
                <p>PCB Footprint</p>
              </div>
              <p>I put all of the components that had external wiring as far up and to the left as possible (on the front). This put them far away from the OLED, opposite the direction the user would be using the interface.</p>
              <p>There is a power plane on the front of the PCB and a ground plane on the back. This made running traces much easier, and reduced the number of vias. The ground planes are also  mostly uninterrupted.</p>
              <p>One important note is that I did end up cutting a trace and moving a connection. This is to match  the revised location as seen in the suggested schematic layout earlier on the page for SENSOR_0:</p>
              <div class="imageCap">
                <img src="../images/portfolio/items/wax_melter/jumped.jpg" alt="Wire ran to jump connection">
                <p>Jumped connection from thermocouple output to A2 instead of A1. Mark on PCB is from sharpie not from soldering.</p>
              </div>
            </div>
          </div>
          <div>
            <h2>Software</h2>
            <p>Complete source code, including code used during key testing and development stages, can be seen on the project <a href=https://github.com/mstites/waxMelter>github</a>.</p>
            <div>
              <h3>OLED UI</h3>
              <p>The first user interface I designed was an OLED user interface for the user to use while next to the candle maker. Below is information about my implementation and process.</p>
              <div class="imageCap">
                <img src="../images/portfolio/items/wax_melter/oledUi.jpg" alt="Photo of OLED interface with screen and buttons">
                <p>Final OLED interface - <a href=https://youtu.be/RmtS1ReG-JI>Video Demonstration</a></p>
                <p>Top and bottom buttons are up and down. Middle button is select.</p>
              </div>
              <div>
                <h4>Ideation & Layout</h4>
                <div class="imageCap large">
                  <img src="../images/portfolio/items/wax_melter/ideation/ideation1.jpg" alt="front of the pcb">
                  <p>Photo of my design notebook with design requirements and initial designs.</p>
                  <img src="../images/portfolio/items/wax_melter/ideation/ideation2.jpg" alt="back of the pcb">
                  <p>Photo of my design notebook with two designs: a multi page slider layout and a single page layout.</p>
                </div>
                <p>Before starting on any software implementation for my OLED user interface, I went through a design ideation process with pen and paper to create an intuitive user design. I first (first photo, first page) made a list of requirements. This included controls and indicators I needed to have on the display. I also drew the physical environment which my user would be using the board to set my mind in the correct space.</p>
                <p>Next (first photo, second page), I explored desired functionality and some initial possible interface options. I thought about how the user might see and interact with information.</p>
                <p>Finally (last two pages), I explored two possible designs for the OLED. The first design was a slider layout where the up and down buttons changed the screen and the middle button selected the option on the screen. The second design was a single panel layout. In this version, the up and down buttons selected the line and the middle button was an enter/select button.</p>
                <p>I decided to move forward with the single panel layout as it made better use of the space on the OLED screen and was less complicated to use. It consisted of only two pages for the user to learn. This mindset of simplicity is also why I chose to not have any sort of heating profiles in the end. Based on experimentation, I found this cluttered this display. I found my final iteration of just one target temperature option on the display made the device much more usable.</p>
              </div>
            </div>
            <div>
              <h3>Web UI</h3>
              <div class="imageCap">
                <img src="../images/portfolio/items/wax_melter/webUi.jpg" alt="Screenshot of web interface" >
                <p>Final web interface - <a href=https://youtu.be/vdPEBDC0jkA>Video Demonstration</a></p>
              </div>
              <div>
                <h4>Process</h4>
                <p>Unlike when working on the OLED interface, I was less focused with reaching a specific interface design. I was more focused on reaching basic functionality. Prior to this project, I had never ran a web server on a device like this.</p>
                <p>The first part of my process was identifying my key challenges. I made four key steps for myself:</p>
                <ol>
                  <li>Connecting to WiFi</li>
                  <li>Hosting a webpage</li>
                  <li>Sending data to webpage that changed (not "static")</li>
                  <li>Recieve data from webpage from user</li>
                </ol>
                <p>I put static in quotes because I am not using it in the traditional static versus dynamic web page way. I mean it simply in the way that data can be updated after the device is powered on.</p>
                <p>I found it quite easy to connect to WiFi. The microcontroller I picked, thanks to its great IoT support has a wonderful WiFi implementation from the espressif package listed in the github. Connecting to  WiFi is as simple as: include the library, set the mode you want to connect (basically, are you a client, a router, or both?), and run the begin statement with connection info:</p>
                <pre>
                  <code>
                    #include &lt;WiFi.h&gt;
                    WiFi.mode(WIFI_STA);
                    WiFi.begin(ssid, password);
                  </code>
                </pre>
                <p>The next few steps were the harder ones. There are many packages for hosting a website on the ESP32, and most of them support sending and recieving data. However, many of them require continually relooping through the HTML code and printing it to the website. This has a high performance  overhead, is difficult to functionize and organize, and makes it hard to perform other more complicated functions with the microcontroller - which I needed to do. In the end, I ended up using the <a href=https://github.com/me-no-dev/ESPAsyncWebServer>ESPAsyncWebServer</a> library.</p>
                <p>This was by far the most complicated and most full featured library I tested. It is a bit tricky to get installed and going. However, once I got things running, it was great. There is lots of documentation and I was able to implement full featured web based interface and pass all kinds of data. More of my code for this package in the next section</p>
              </div>
              <div>
                <h4>Key Code Snippets</h4>
                <p>For my final implementation of the web UI, I used <a href=https://github.com/me-no-dev/ESPAsyncWebServer>ESPAsyncWebServer</a> for my interface and for handeling data. The built in espressif WiFi library was used for connectivity.</p>
                <p>Before starting the web server, all constants and variables are defined. This includes the wifi connection info and the port of the server. But it also includes the page information:</p>
                <ul>
                  <li>HTML with variables that will be connected to the code</li>
                  <li>A C function to connect the HTML variables with the C variables, converting them to strings. More information below.</li>
                  <li>Heat slider code</li>
                  <li>A simple yes/no function to control the button slider based on the  heating value</li>
                  <li>Bare bones 404 page</li>
                </ul>
                <p>Code to connect HTML with C variables:</p>
                <pre>
                  <code>
                    String processor(const String&amp; var){
                      //Serial.println(var);
                      if(var == &quot;CURR_TEMP&quot;){
                        // current temp status
                        return String(currentTemp);
                      }
                      else if(var == &quot;TARG_TEMP&quot;){
                        // target temp status
                        return String(targetTemp);
                      }
                      else if(var == &quot;NEW_TARGET&quot;){
                        // new target value in input field
                        return String(targetTemp);
                      }
                      else if(var == &quot;HEAT_SLIDER&quot;){
                        String buttons = &quot;&quot;;
                        // replace button placeholder
                        buttons += (BUTTON HTML)
                        return buttons;
                      }
                      return String();
                    }
                  </code>
                </pre>
                <p>The var values are the variables coming from the page HTML. The return values are strings of values in the C environment on the  HUZZAH32. The first two if statements are setting the values for the temperature status indicators: for current temperature and target temperature respectively. The third value is the new target field which is by default populated with the last target temp.</p>
                <p>the last else if in this function is for the heater control slider. This replaces a place holder in the HTML code with a live button. I removed the button HTML code for simplicity in this example, but here it is isolated:</p>
                <pre>
                  <code>
                    else if(var == &quot;HEAT_SLIDER&quot;){
                      String buttons = &quot;&quot;;
                      buttons +=
                      &quot;&lt;h3&gt;Heating:&lt;/h3&gt;
                      &lt;label class=&quot;switch&quot;&gt;
                      &lt;input type=&quot;checkbox&quot;
                      onchange=&quot;toggleCheckbox(this)&quot;
                      id=&quot;2&quot; &quot; + outputState() + &quot;&gt;
                      &lt;span class=&quot;slider&quot;&gt;&lt;/span&gt;&lt;/label&gt;&quot;;
                      return buttons;
                    }
                  </code>
                </pre>
                <p>This code is a modified version of <a  href="https://randomnerdtutorials.com/about/">Rui Santos's</a> work, who written many guides on the ESP32. This snippet creates an HTML button element. The most important items here for later for our are the sections after "onchange". The toggleCheckbox references a javascript portion embedded in the original code which sends a signal that something has been updated and changes a state. This is important because otherwise there is no way of knowing an event, or what event occured.</p>
                <p>The outputState runs a C function to match the button with the local variable:</p>
                <pre>
                  <code>
                    String outputState(){
                      if(heating){
                        return &quot;checked&quot;;
                      }
                      else {
                        return &quot;&quot;;
                      }
                    }
                  </code>
                </pre>
                <p>The final key snippet of code I am going to put is the server initializing function which contains the monitoring code for updates, as mentioned earlier. Here is the monitoring code, once again huge thanks to Rui Santos:</p>
                <pre>
                  <code>
                    server.on(&quot;/update&quot;, HTTP_GET, [] (AsyncWebServerRequest *request) {
                      if (request-&gt;hasParam(PARAM_INPUT_1)) {
                        // if target temp change
                        targetTemp = (request-&gt;getParam(PARAM_INPUT_1)-&gt;value()).toInt();
                      }
                      else if (request-&gt;hasParam(PARAM_INPUT_2)) {
                        // if heating status change
                        int input = (request-&gt;getParam(PARAM_INPUT_2)-&gt;value()).toInt();
                        if (input == 1){
                          heating = true;
                        }
                        else {
                          heating = false;
                        }
                      }
                    });
                  }
                </code>
              </pre>
              <p>When there is an update signal sent by one of the two inputs, this part of the code will be ran (hence the server.on ... "/update"). The first if statement checks PARAM_INPUT_1 which is a pointer to the target temperature input. Thus if the update contains that param, it is a temperature input and that value is updated.</p>
              <p>Alternatively, if the value contains PARAM_INPUT_2, it corresponds to a state change in heating. PARAM_INPUT_2 is a pointer to the state value of the button. So when that value changes on an update, the heating value is changed as well.</p>
            </div>
          </div>
        </div>
        <a href="../index.html">Return to my personal website and portfolio</a>
      </div>
    </body>
    </html>
